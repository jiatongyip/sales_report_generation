# LangGraph workflow for sales report generation using GeminiClient
# Full skeleton with state, nodes, agent prompts, tools, and docstrings

import logging
from typing import TypedDict, List, Dict, Any, Optional
from langgraph.graph import StateGraph, END, START
from langgraph.prebuilt import ToolNode
from langchain_core.messages import HumanMessage, AIMessage

from src.prompts import (
    SALES_TREND_PROMPT, TOP_PERFORMER_PROMPT, 
    KEY_DRIVER_PROMPT, GENERIC_ANALYSIS_PROMPT, REPORT_WRITER_PROMPT
)
from src.tools import (
    preview_data,
    top_performers,
    under_performers,
    ols_key_driver_analysis,
    generate_simple_plot,
    assemble_simple_report_docx
)
from src.utils import GeminiClient
import json
#############################################
# LOGGING SETUP
#############################################
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s"
)
logger = logging.getLogger(__name__)


#############################################
# 1. GEMINI CLIENT
#############################################

# Shared instance
llm = GeminiClient()

#############################################
# 2. STATE
#############################################
class ReportState(TypedDict, total=False):
    """
    Workflow state for the sales report pipeline.

    Attributes
    ----------
    input_data_path : str
        Path to the sales dataset to analyze.

    *_text : Optional[str]
        Textual output from each agent.

    *_plots : Optional[List[str]]
        File paths of plots generated by each agent.

    final_report_text : Optional[str]
        Final compiled report text from the report writer agent.

    final_report_docx_path : Optional[str]
        Final document path (optional extension).
    """
    input_data_path: str
    sales_trend_text: Optional[str]
    sales_trend_plots: Optional[List[str]]
    performer_text: Optional[str]
    performer_plots: Optional[List[str]]
    key_driver_text: Optional[str]
    key_driver_plots: Optional[List[str]]
    generic_analysis_text: Optional[str]
    generic_analysis_plots: Optional[List[str]]
    final_report_text: Optional[str]
    final_report_docx_path: Optional[str]


#############################################
# 5. NODE FUNCTIONS
#############################################
def run_agent(state: ReportState, prompt: str, tools=List) -> Any:
    """
    Executes a single agent using Gemini function-calling.
    """
    logger.info(f"Running agent with prompt: {prompt[:20]}... tools={[t.__name__ for t in tools]}")

    user_prompt = f"Data path: {state['input_data_path']}. Use tools to analyze."
    response = llm.generate(prompt=user_prompt, system_instruction=prompt, tools=tools)
    logger.info(f"Raw LLM response: {response}")
    return response


def sales_trend_node(state: ReportState) -> ReportState:
    logger.info("Running Sales Trend Agent...")
    out = run_agent(state, SALES_TREND_PROMPT, tools=[preview_data, generate_simple_plot])

    state_update = {}
    state_update["sales_trend_text"] = out.get("text", "")
    state_update["sales_trend_plots"] = out.get("plots", [])

    logger.info(f"Sales Trend Agent completed. Text length={len(state_update['sales_trend_text'])}")
    return state_update


def top_performer_node(state: ReportState) -> ReportState:
    logger.info("Running Top Performer Agent...")
    out = run_agent(
        state,
        TOP_PERFORMER_PROMPT,
        tools=[preview_data, generate_simple_plot, top_performers, under_performers]
    )
    state_update = {}
    state_update["performer_text"] = out.get("text", "")
    state_update["performer_plots"] = out.get("plots", [])

    logger.info("Top Performer Agent completed.")
    return state_update


def key_driver_node(state: ReportState) -> ReportState:
    logger.info("Running Key Driver Agent...")
    out = run_agent(
        state,
        KEY_DRIVER_PROMPT,
        tools=[preview_data, generate_simple_plot, ols_key_driver_analysis]
    )
    state_update = {}
    state_update["key_driver_text"] = out.get("text", "")
    state_update["key_driver_plots"] = out.get("plots", [])

    logger.info("Key Driver Agent completed.")
    return state_update


def generic_analysis_node(state: ReportState) -> ReportState:
    logger.info("Running Generic Analysis Agent...")
    out = run_agent(
        state,
        GENERIC_ANALYSIS_PROMPT,
        tools=[preview_data, generate_simple_plot, top_performers, under_performers, ols_key_driver_analysis]
    )
    state_update = {}
    state_update["generic_analysis_text"] = out.get("text", "")
    state_update["generic_analysis_plots"] = out.get("plots", [])

    logger.info("Generic Analysis Agent completed.")
    return state_update


def report_writer_node(state: ReportState) -> ReportState:
    logger.info("Running Report Writer Agent...")    
    out = llm.generate(
        prompt="Compile report from all state fields.",
        system_instruction=REPORT_WRITER_PROMPT.format(agent_output = str(state)),
        tools=[assemble_simple_report_docx]
    )
    logger.info(f"Raw LLM response: {out}")
    state["final_report_text"] = out.get("text", "")

    logger.info("Report Writer Agent completed. Final report length="
                f"{len(state['final_report_text'])}")
    return state


#############################################
# 6. GRAPH
#############################################
def run_workflow(state: ReportState):
    logger.info("Building LangGraph workflow...")

    graph = StateGraph(ReportState)
    graph.add_node("sales_trend", sales_trend_node)
    graph.add_node("top_performer", top_performer_node)
    graph.add_node("key_driver", key_driver_node)
    graph.add_node("generic_analysis", generic_analysis_node)
    graph.add_node("report_writer", report_writer_node)

    parallel_nodes = [
        "sales_trend",
        "top_performer",
        "key_driver",
        "generic_analysis",
    ]

    for node in parallel_nodes:
        logger.info(f"Adding edge: start -> {node}")
        graph.add_edge(START, node)

    for node in parallel_nodes:
        logger.info(f"Adding edge: {node} -> report_writer")
        graph.add_edge(node, "report_writer")

    graph.add_edge("report_writer", END)
    workflow = graph.compile()

    logger.info("Workflow compiled. Executing workflow...")

    final_state = workflow.invoke(state)

    logger.info("Workflow execution completed.")
    return final_state
